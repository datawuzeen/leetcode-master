<p align="center">
<a href="https://mp.weixin.qq.com/s/QVF6upVMSbgvZy8lHZS3CQ" target="_blank">
  <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210924105952.png" width="1000"/>
</a>
<p align="center"><strong><a href="https://mp.weixin.qq.com/s/tqCxrMEU-ajQumL1i8im9A">参与本项目</a>，贡献其他语言版本的代码，拥抱开源，让更多学习算法的小伙伴们收益！</strong></p>


# 404.左叶子之和

[力扣题目链接](https://leetcode-cn.com/problems/sum-of-left-leaves/)

计算给定二叉树的所有左叶子之和。

示例：

![404.左叶子之和1](https://img-blog.csdnimg.cn/20210204151927654.png)

# 思路

## 非递归法

层次遍历，出节点时，判断节点的左孩子是否为叶子节点。

```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        Deque<TreeNode> deque = new LinkedList<>();

        if(root == null) return 0;
        
        int count = 0;
        deque.offerLast(root);
        while(!deque.isEmpty()){
            int len = deque.size();
            while(len > 0){
                TreeNode node = deque.pollFirst();
                if(node.left != null){
                    if(node.left.left == null && node.left.right == null) count += node.left.val;
                    deque.offerLast(node.left);
                }
                if(node.right != null){
                    deque.offerLast(node.right);
                }
                len--;
            }
        }

        return count;
    }
}
```


## 递归法

判断坐叶子的核心：1. 是否为叶子节点；2. 是否为左节点

第一个条件很好判断，遍历到某个节点时，判断就可以的

第二个条件需要由上一层传入

```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if(root == null) return 0;

        return dfs(root.left, 1) + dfs(root.right, 2); 
    }

    public int dfs(TreeNode node, int flag){
        if(node == null) return 0;

        int leftCount = dfs(node.left, 1);
        int rightCount = dfs(node.right, 2);

        if(node.left == null && node.right == null && flag == 1) return node.val;
        else return leftCount + rightCount;
    }
}
```
